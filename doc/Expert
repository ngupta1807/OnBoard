polymorphism
interface & abstrat difference
async & syncronization
When you execute something synchronously, you wait for it to finish before moving on to another task.
When you execute something asynchronously, you can move on to another task before it finishes.
Hash table  & hash map
Arraylist & vectorlist
Marking the class "final" means that no other class can extend it and hence abstract classes cannot be marked final. 
map & 


Q1)error string resource id #0*30
Ams)you are trying to display int in toast.

Soap: containing the following elements:
Envalop,Head,body,fault.

soap header.
xmpp connection method.
=> Connectionmanager

swap two number
a=5 b=10
a=a+b; 15
b=a-b;  5
a=a+b; 10


what is android :os 

service & intent service

IntentService is a base class for Services that handle asynchronous requests using onHandleIntent method.
Service is an application component that can perform long-running operations in the background.

passing data from Fragment to activity:

Bundle bundle = new Bundle();
bundle.putString("message", "Alo Elena!");
FragmentClass fragInfo = new FragmentClass();
fragInfo.setArguments(bundle);
transaction.replace(R.id.fragment_single, fragInfo);
transaction.commit();

stop and pause diff.

diffrence bt activity and frgment life cycle.


com.android.library = > says that this is a library.
com.android.application = > says that this is a project and will generate apk.


The advantages of using LiveData:
1. Ensures your UI matches your data state
    LiveData follows the observer pattern. LiveData notifies Observer objects when the lifecycle state changes. You can consolidate your code to update the UI in these Observer objects. Instead of updating the UI every time the app data changes, your observer can update the UI every time there's a change.
2.No memory leaks
    Observers are bound to Lifecycle objects and clean up after themselves when their associated lifecycle is destroyed.
3. No crashes due to stopped activities
    If the observer's lifecycle is inactive, such as in the case of an activity in the back stack, then it doesn’t receive any LiveData events.
4. No more manual lifecycle handling
    UI components just observe relevant data and don’t stop or resume observation. LiveData automatically manages all of this since it’s aware of the relevant lifecycle status changes while observing.
5. Always up to date data
    If a lifecycle becomes inactive, it receives the latest data upon becoming active again. For example, an activity that was in the background receives the latest data right after it returns to the foreground.
6. Proper configuration changes
    If an activity or fragment is recreated due to a configuration change, like device rotation, it immediately receives the latest available data.
7. Sharing resources
    You can extend a LiveData object using the singleton pattern to wrap system services so that they can be shared in your app. The LiveData object connects to the system service once, and then any observer that needs the resource can just watch the LiveData object.
