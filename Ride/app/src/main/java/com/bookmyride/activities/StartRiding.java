package com.bookmyride.activities;import android.Manifest;import android.animation.ValueAnimator;import android.app.AlertDialog;import android.app.Dialog;import android.content.BroadcastReceiver;import android.content.Context;import android.content.DialogInterface;import android.content.Intent;import android.content.IntentFilter;import android.content.pm.PackageManager;import android.graphics.Color;import android.graphics.drawable.ColorDrawable;import android.location.Location;import android.net.Uri;import android.os.AsyncTask;import android.os.Build;import android.os.Bundle;import android.os.Handler;import android.os.SystemClock;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v4.content.LocalBroadcastManager;import android.support.v7.app.AppCompatActivity;import android.view.Gravity;import android.view.LayoutInflater;import android.view.MotionEvent;import android.view.View;import android.view.Window;import android.view.WindowManager;import android.view.animation.Interpolator;import android.view.animation.LinearInterpolator;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.EditText;import android.widget.LinearLayout;import android.widget.ListView;import android.widget.SeekBar;import android.widget.TextView;import android.widget.Toast;import com.google.android.gms.common.ConnectionResult;import com.google.android.gms.common.api.GoogleApiClient;import com.google.android.gms.location.LocationListener;import com.google.android.gms.location.LocationRequest;import com.google.android.gms.location.LocationServices;import com.google.android.gms.maps.CameraUpdate;import com.google.android.gms.maps.CameraUpdateFactory;import com.google.android.gms.maps.GoogleMap;import com.google.android.gms.maps.OnMapReadyCallback;import com.google.android.gms.maps.SupportMapFragment;import com.google.android.gms.maps.model.BitmapDescriptorFactory;import com.google.android.gms.maps.model.LatLng;import com.google.android.gms.maps.model.LatLngBounds;import com.google.android.gms.maps.model.Marker;import com.google.android.gms.maps.model.MarkerOptions;import com.google.android.gms.maps.model.Polyline;import com.google.android.gms.maps.model.PolylineOptions;import com.google.maps.android.PolyUtil;import com.bookmyride.R;import com.bookmyride.api.APIHandler;import com.bookmyride.api.APIStatus;import com.bookmyride.api.AsyncTaskCompleteListener;import com.bookmyride.api.Config;import com.bookmyride.api.HTTPMethods;import com.bookmyride.api.Key;import com.bookmyride.common.Internet;import com.bookmyride.common.SessionHandler;import com.bookmyride.fcm.NotificationFilters;import com.bookmyride.fcm.NotificationUtils;import com.bookmyride.map.DirectionsJSONParser;import com.bookmyride.services.TrackGPS;import com.bookmyride.util.LatLngInterpolator;import com.romainpiel.shimmer.Shimmer;import com.romainpiel.shimmer.ShimmerButton;import org.json.JSONException;import org.json.JSONObject;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import java.util.ArrayList;import java.util.HashMap;import java.util.List;public class StartRiding extends AppCompatActivity        implements View.OnTouchListener, AsyncTaskCompleteListener,        SeekBar.OnSeekBarChangeListener, OnMapReadyCallback,        GoogleApiClient.ConnectionCallbacks,        GoogleApiClient.OnConnectionFailedListener, LocationListener {    TrackGPS gps;    double latitude, longitude;    GoogleMap googleMap;    SeekBar sliderSeekBar;    ShimmerButton slider;    Shimmer shimmer;    String bookingId, passengerName, passengerPhone;    SessionHandler session;    String puLat = "0.0", puLng = "0.0";    TextView rideId, name, /*mobile,*/            pmtStatus;    private BroadcastReceiver mReceiver;    LinearLayout layContact;    String driverLat = "", driverLng = "";    private LatLng fromPosition;    private LatLng toPosition;    LocationRequest mLocationRequest;    GoogleApiClient mGoogleApiClient;    Location mLastLocation;    Marker mCurrLocationMarker;    String driverCategory;    String bookingType, paymentStatus;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.start_riding);        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);        init();        driverCategory = getIntent().getStringExtra("driverCategory");        updatesliderUI();        if (gps.canGetLocation()) {            latitude = gps.getLatitude();            longitude = gps.getLongitude();        }        bookingId = getIntent().getStringExtra("bookingId");        passengerName = getIntent().getStringExtra("passenger_name");        passengerPhone = getIntent().getStringExtra("passenger_phone");        rideId.setText("RIDE_ID: " + bookingId);        name.setText("Passenger: " + passengerName);        //mobile.setText(passengerPhone);        //mobile.setText("Contact Passenger");        String pickup = getIntent().getStringExtra("pickUp");        paymentStatus = getIntent().getStringExtra("payment_status");        bookingType = getIntent().getStringExtra("type");        if (paymentStatus.equals("1"))            pmtStatus.setVisibility(View.VISIBLE);        else pmtStatus.setVisibility(View.GONE);        try {            JSONObject puObj = new JSONObject(pickup);            puLat = puObj.getString("lat");            puLng = puObj.getString("lng");        } catch (JSONException e) {            e.printStackTrace();        }        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            if (checkLocationPermission())                initializeMap();        } else            initializeMap();    }    private void init() {        session = new SessionHandler(this);        gps = new TrackGPS(this);        rideId = (TextView) findViewById(R.id.ride_id);        name = (TextView) findViewById(R.id.name);        //mobile = (TextView) findViewById(R.id.mobile);        pmtStatus = (TextView) findViewById(R.id.payment_status);        layContact = (LinearLayout) findViewById(R.id.lay_contact);        layContact.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                showRideDialog();            }        });        sliderSeekBar = (SeekBar) findViewById(R.id.begin_Trip_seek);        slider = (ShimmerButton) findViewById(R.id.begin_Trip_slider_button);        //Rl_beginTrip = (RelativeLayout) findViewById(R.id.layout_begintrip);        initSlider();        mReceiver = new BroadcastReceiver() {            @Override            public void onReceive(Context context, Intent intent) {                if (intent.getAction().equals(NotificationFilters.REQUEST_CANCELLED)) {                    if (session.getUserType().equals("4")) {                        try {                            JSONObject obj = new JSONObject(intent.getStringExtra("rideData"));                            final View layout = getLayoutInflater().inflate(R.layout.customtoast, null);                            TextView message = (TextView) layout.findViewById(R.id.message);                            message.setText(obj.getString("message"));                            TextView title = (TextView) layout.findViewById(R.id.title);                            title.setText(getResources().getString(R.string.app_name));                            new Handler().postDelayed(new Runnable() {                                @Override                                public void run() {                                    final Toast toast = new Toast(getApplicationContext());                                    toast.setDuration(Toast.LENGTH_LONG);                                    toast.setGravity(Gravity.TOP | Gravity.FILL_HORIZONTAL, 0, 0);                                    toast.setView(layout);                                    toast.show();                                }                            }, 500);                            new Handler().postDelayed(new Runnable() {                                @Override                                public void run() {                                    StartRiding.this.finish();                                }                            }, 3000);                        } catch (JSONException e) {                            e.printStackTrace();                        }                    }                }            }        };    }    private void initSlider() {        shimmer = new Shimmer();        shimmer.start(slider);        sliderSeekBar.setOnSeekBarChangeListener(this);    }    private void initializeMap() {        if (googleMap == null) {            SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager()                    .findFragmentById(R.id.map);            mapFragment.getMapAsync(this);        }    }    @Override    public void onMapReady(GoogleMap map) {        googleMap = map;        // Move the camera to last position with a zoom level        CameraUpdate cameraUpdate = CameraUpdateFactory.newLatLngZoom(new LatLng(gps.getLatitude(), gps.getLongitude()), 12);        googleMap.animateCamera(cameraUpdate);        /*CameraPosition cameraPosition = new CameraPosition.Builder().target(new LatLng(gps.getLatitude(), gps.getLongitude())).build();        googleMap.moveCamera(CameraUpdateFactory.newCameraPosition(cameraPosition));*/        //Initialize Google Play Services        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            if (ContextCompat.checkSelfPermission(this,                    Manifest.permission.ACCESS_FINE_LOCATION)                    == PackageManager.PERMISSION_GRANTED) {                buildGoogleApiClient();                googleMap.setMyLocationEnabled(false);                googleMap.getUiSettings().setMyLocationButtonEnabled(false);            }        } else {            buildGoogleApiClient();            googleMap.setMyLocationEnabled(false);            googleMap.getUiSettings().setMyLocationButtonEnabled(false);        }        driverLat = "" + gps.getLatitude();        driverLng = "" + gps.getLongitude();        drawRoute();    }    private void drawRoute() {        if (!driverLat.equals("") && !driverLng.equals("")) {            fromPosition = new LatLng(Double.parseDouble(driverLat), Double.parseDouble(driverLng));            toPosition = new LatLng(Double.parseDouble(puLat), Double.parseDouble(puLng));            if (fromPosition != null && toPosition != null) {                googleMap.addMarker(new MarkerOptions()                        .position(fromPosition)                        .icon(BitmapDescriptorFactory.fromResource(R.drawable.red_dot)));                googleMap.addMarker(new MarkerOptions()                        .position(toPosition)                        .icon(BitmapDescriptorFactory.fromResource(R.drawable.green_dot)));                /* String url = getDirectionsUrl(fromPosition, null, toPosition);                DownloadTask downloadTask = new DownloadTask();                downloadTask.execute(url); */            }        }    }    @Override    public void onProgressChanged(SeekBar seekBar, int i, boolean b) {    }    @Override    public void onStartTrackingTouch(SeekBar seekBar) {        slider.setVisibility(View.VISIBLE);    }    @Override    public void onStopTrackingTouch(SeekBar seekBar) {        //call api        if (seekBar.getProgress() > 90) {            sliderSeekBar.setProgress(2);            driverArrived("12");        } else {            sliderSeekBar.setProgress(2);        }        updatesliderUI();    }    private void updatesliderUI() {        if (driverCategory.equals("1"))            sliderSeekBar.setThumb(getResources().getDrawable(R.drawable.slider_taxi));        else if (driverCategory.equals("2"))            sliderSeekBar.setThumb(getResources().getDrawable(R.drawable.slider_economy));        else if (driverCategory.equals("3"))            sliderSeekBar.setThumb(getResources().getDrawable(R.drawable.slider_premium));        else if (driverCategory.equals("4"))            sliderSeekBar.setThumb(getResources().getDrawable(R.drawable.slider_motor_bike));    }    @Override    public boolean onTouch(View view, MotionEvent motionEvent) {        return false;    }    private void driverArrived(String status) {        type = 0;        HashMap<String, String> jsonParams = new HashMap<String, String>();        jsonParams.put("status", status);        if (Internet.hasInternet(this)) {            APIHandler apiHandler = new APIHandler(this, HTTPMethods.PUT, this, jsonParams);            apiHandler.execute(Config.BOOKING_STATUS + bookingId, session.getToken());        } else            Error("Alert!", getResources().getString(R.string.no_internet));    }    @Override    public void onTaskComplete(String result) {        handleResponse(result);    }    private void handleResponse(String result) {        try {            JSONObject outJson = new JSONObject(result);            if (outJson.getInt(Key.STATUS) == APIStatus.SUCCESS) {                if (type == 0) {                    session.saveWaitingInfo(0L, 0L, 0L, 0L, 0, 0);                    startActivity(new Intent(StartRiding.this, DriverArrived.class)                            .putExtra("bookingId", bookingId)                            .putExtra("passenger_name", passengerName)                            .putExtra("passenger_phone", passengerPhone)                            .putExtra("type", bookingType)                            .putExtra("is_discount", getIntent().getBooleanExtra("is_discount", false))                            .putExtra("payment_status", paymentStatus)                            .putExtra("pickUp", getIntent().getStringExtra("pickUp"))                            .putExtra("driverCategory", getIntent().getStringExtra("driverCategory"))                            .putExtra("dropOff", getIntent().getStringExtra("dropOff")));                    overridePendingTransition(R.anim.fade_in, R.anim.fade_out);                    StartRiding.this.finish();                } else if (type == 1) {                    Error("Success!", "Message has sent to driver.");                }            } else {                Error("Alert!", outJson.getJSONArray(Key.DATA).getJSONObject(0).getString(Key.MESSAGE));                initSlider();            }        } catch (JSONException e) {            e.printStackTrace();            initSlider();        }    }    private void Error(String title, String message) {        final com.bookmyride.views.AlertDialog mDialog = new com.bookmyride.views.AlertDialog(StartRiding.this, true);        mDialog.setDialogTitle(title);        mDialog.setDialogMessage(message);        mDialog.setPositiveButton(getResources().getString(R.string.ok), new View.OnClickListener() {            @Override            public void onClick(View v) {                mDialog.dismiss();            }        });        mDialog.show();    }    @Override    protected void onResume() {        super.onResume();        LocalBroadcastManager.getInstance(this).registerReceiver(mReceiver,                new IntentFilter(NotificationFilters.REQUEST_CANCELLED));        NotificationUtils.clearNotifications(getApplicationContext());    }    @Override    protected void onPause() {        LocalBroadcastManager.getInstance(this).unregisterReceiver(mReceiver);        super.onPause();    }    @Override    protected void onDestroy() {        LocalBroadcastManager.getInstance(this).unregisterReceiver(mReceiver);        LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, this);        if (googleMap != null) {            googleMap.clear();            googleMap = null;        }        super.onDestroy();    }    public void showRideDialog() {        final Dialog mDialog = new Dialog(StartRiding.this, R.style.rideDialog);        mDialog.setCancelable(false);        mDialog.requestWindowFeature(Window.FEATURE_NO_TITLE);        mDialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));        mDialog.setContentView(R.layout.fragment_list);        mDialog.setCanceledOnTouchOutside(true);        TextView title = (TextView) mDialog.findViewById(R.id.title);        title.setVisibility(View.VISIBLE);        title.setText("Select Contact Type");        mDialog.setOnCancelListener(new DialogInterface.OnCancelListener() {            @Override            public void onCancel(DialogInterface dialog) {                mDialog.dismiss();            }        });        mDialog.setOnDismissListener(new DialogInterface.OnDismissListener() {            @Override            public void onDismiss(DialogInterface dialog) {                mDialog.dismiss();            }        });        ListView dialog_ListView = (ListView) mDialog.findViewById(R.id.list);        ArrayAdapter<String>                adapter = new ArrayAdapter<>(this,                R.layout.simple_list_item, R.id.textItem, getContactType());        dialog_ListView.setAdapter(adapter);        dialog_ListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {            @Override            public void onItemClick(AdapterView<?> parent, View view,                                    int position, long id) {                if (parent.getItemAtPosition(position).toString().equals("SMS")) {                    showMessageDialog();                } else {                    callPassenger();                }                mDialog.dismiss();            }        });        mDialog.show();    }    private void callPassenger() {        if (Build.VERSION.SDK_INT >= 23) {            // Marshmallow+            if (!checkCallPhonePermission() || !checkReadStatePermission()) {                requestPermission();            } else {                Intent callIntent = new Intent(Intent.ACTION_CALL);                callIntent.setData(Uri.parse("tel:" + passengerPhone));                startActivity(callIntent);            }        } else {            Intent callIntent = new Intent(Intent.ACTION_CALL);            callIntent.setData(Uri.parse("tel:" + passengerPhone));            startActivity(callIntent);        }    }    private boolean checkCallPhonePermission() {        int result = ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE);        if (result == PackageManager.PERMISSION_GRANTED) {            return true;        } else {            return false;        }    }    private boolean checkReadStatePermission() {        int result = ContextCompat.checkSelfPermission(this, Manifest.permission.READ_PHONE_STATE);        if (result == PackageManager.PERMISSION_GRANTED) {            return true;        } else {            return false;        }    }    private void requestPermission() {        ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CALL_PHONE, Manifest.permission.READ_PHONE_STATE}, PERMISSION_REQUEST_CODE);    }    final int PERMISSION_REQUEST_CODE = 111;    private void showMessageDialog() {        LayoutInflater inflater = LayoutInflater.from(StartRiding.this);        View subView = inflater.inflate(R.layout.message_dialog, null);        final EditText subEditText = (EditText) subView.findViewById(R.id.bid_price);        TextView proceed = (TextView) subView.findViewById(R.id.send);        TextView cancel = (TextView) subView.findViewById(R.id.cancel);        AlertDialog.Builder builder = new AlertDialog.Builder(StartRiding.this);        builder.setView(subView);        final AlertDialog alertDialog = builder.create();        proceed.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                if (subEditText.getText().toString().length() > 0) {                    alertDialog.dismiss();                    sendMessageToDriver(subEditText.getText().toString());                } else                    Error("Alert!", "Please enter message.");            }        });        cancel.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                alertDialog.dismiss();            }        });        alertDialog.show();    }    int type;    private void sendMessageToDriver(String message) {        type = 1;        HashMap<String, String> params = new HashMap<String, String>();        params.put("msgFrom", session.getUserID());        params.put("msgTo", passengerPhone);        params.put("booking_id", bookingId);        params.put("msg", message);        //Log.e("param", params.toString());        APIHandler apiHandler = new APIHandler(this, HTTPMethods.POST, this, params);        apiHandler.execute(Config.SEND_MESSAGE_DRIVER, session.getToken());    }    public String[] getContactType() {        String[] gateway = getResources().getStringArray(R.array.contact_via);        return gateway;    }    private String getDirectionsUrl(LatLng origin, LatLng wayPoint, LatLng dest) {        // Origin of route        String str_origin = "origin=" + origin.latitude + "," + origin.longitude;        String str_dest = "destination=" + dest.latitude + "," + dest.longitude;        // Sensor enabled        String sensor = "sensor=false";        // Building the parameters to the web service        String parameters;        if (wayPoint != null) {            String waypoints = "waypoints=optimize:true|" + wayPoint.latitude + "," + wayPoint.longitude + "|";            parameters = str_origin + "&" + waypoints + "&" + str_dest + "&" + sensor;        } else {            parameters = str_origin + "&" + str_dest + "&" + sensor;        }        // Output format        String output = "json";        // Building the url to the web service        String url = "https://maps.googleapis.com/maps/api/directions/" + output + "?" + parameters;        return url;    }    /**     * A method to download json data from url     */    private String downloadUrl(String strUrl) throws IOException {        String data = "";        InputStream iStream = null;        HttpURLConnection urlConnection = null;        try {            URL url = new URL(strUrl);            // Creating an http connection to communicate with url            urlConnection = (HttpURLConnection) url.openConnection();            // Connecting to url            urlConnection.connect();            // Reading data from url            iStream = urlConnection.getInputStream();            BufferedReader br = new BufferedReader(new InputStreamReader(iStream));            StringBuffer sb = new StringBuffer();            String line = "";            while ((line = br.readLine()) != null) {                sb.append(line);            }            data = sb.toString();            br.close();        } catch (Exception e) {            e.printStackTrace();        } finally {            iStream.close();            urlConnection.disconnect();        }        return data;    }    /**     * A class to download data from Google Directions URL     */    private class DownloadTask extends AsyncTask<String, Void, String> {        // Downloading data in non-ui thread        @Override        protected String doInBackground(String... url) {            // For storing data from web service            String data = "";            try {                // Fetching the data from web service                data = downloadUrl(url[0]);            } catch (Exception e) {                e.printStackTrace();            }            return data;        }        // Executes in UI thread, after the execution of        // doInBackground()        @Override        protected void onPostExecute(String result) {            super.onPostExecute(result);            ParserTask parserTask = new ParserTask();            // Invokes the thread for parsing the JSON data            parserTask.execute(result);        }    }    /**     * A class to parse the Google Directions in JSON format     */    private class ParserTask extends AsyncTask<String, Integer, List<List<HashMap<String, String>>>> {        // Parsing the data in non-ui thread        @Override        protected List<List<HashMap<String, String>>> doInBackground(String... jsonData) {            JSONObject jObject;            List<List<HashMap<String, String>>> routes = null;            try {                jObject = new JSONObject(jsonData[0]);                DirectionsJSONParser parser = new DirectionsJSONParser();                // Starts parsing data                routes = parser.parse(jObject);            } catch (Exception e) {                e.printStackTrace();            }            return routes;        }        // Executes in UI thread, after the parsing process        @Override        protected void onPostExecute(List<List<HashMap<String, String>>> result) {            ArrayList<LatLng> points = null;            PolylineOptions lineOptions = null;            // Traversing through all the routes            for (int i = 0; i < result.size(); i++) {                points = new ArrayList<LatLng>();                lineOptions = new PolylineOptions();                // Fetching i-th route                List<HashMap<String, String>> path = result.get(i);                // Fetching all the points in i-th route                for (int j = 0; j < path.size(); j++) {                    HashMap<String, String> point = path.get(j);                    double lat = Double.parseDouble(point.get("lat"));                    double lng = Double.parseDouble(point.get("lng"));                    LatLng position = new LatLng(lat, lng);                    points.add(position);                }                // Adding all the points in the route to LineOptions                lineOptions.addAll(points);                lineOptions.width(10);                lineOptions.color(Color.RED);            }            // Drawing polyline in the Google Map for the i-th route            googleMap.addPolyline(lineOptions);            LatLngBounds.Builder bc = new LatLngBounds.Builder();            for (LatLng item : points) {                bc.include(item);            }            googleMap.animateCamera(CameraUpdateFactory.newLatLngBounds(bc.build(), 50));        }    }    public static final int MY_PERMISSIONS_REQUEST_LOCATION = 99;    public boolean checkLocationPermission() {        if (ContextCompat.checkSelfPermission(this,                Manifest.permission.ACCESS_FINE_LOCATION)                != PackageManager.PERMISSION_GRANTED) {            if (ActivityCompat.shouldShowRequestPermissionRationale(this,                    Manifest.permission.ACCESS_FINE_LOCATION)) {                ActivityCompat.requestPermissions(this,                        new String[]{Manifest.permission.ACCESS_FINE_LOCATION},                        MY_PERMISSIONS_REQUEST_LOCATION);            } else {                // No explanation needed, we can request the permission.                ActivityCompat.requestPermissions(this,                        new String[]{Manifest.permission.ACCESS_FINE_LOCATION},                        MY_PERMISSIONS_REQUEST_LOCATION);            }            return false;        } else {            return true;        }    }    @Override    public void onRequestPermissionsResult(int requestCode,                                           String permissions[], int[] grantResults) {        switch (requestCode) {            case MY_PERMISSIONS_REQUEST_LOCATION:                if (grantResults.length > 0                        && grantResults[0] == PackageManager.PERMISSION_GRANTED) {                    if (ContextCompat.checkSelfPermission(this,                            Manifest.permission.ACCESS_FINE_LOCATION)                            == PackageManager.PERMISSION_GRANTED) {                        googleMap.setMyLocationEnabled(false);                        googleMap.getUiSettings().setMyLocationButtonEnabled(false);                        initializeMap();                    }                } else {                    Toast.makeText(this, "permission denied", Toast.LENGTH_LONG).show();                }                break;            case PERMISSION_REQUEST_CODE:                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {                    /*if (sPhoneMasking_Status.equalsIgnoreCase("Yes")) {                        postRequest_PhoneMasking(Iconstant.phone_masking_url);                    } else {                        Intent callIntent = new Intent(Intent.ACTION_CALL);                        callIntent.setData(Uri.parse("tel:" + driverMobile));                        startActivity(callIntent);                    }*/                }                break;        }    }    protected synchronized void buildGoogleApiClient() {        mGoogleApiClient = new GoogleApiClient.Builder(this)                .addConnectionCallbacks(this)                .addOnConnectionFailedListener(this)                .addApi(LocationServices.API)                .build();        mGoogleApiClient.connect();    }    @Override    public void onConnected(Bundle bundle) {        mLocationRequest = new LocationRequest();        mLocationRequest.setInterval(3000);        mLocationRequest.setFastestInterval(3000);        mLocationRequest.setSmallestDisplacement(0.1f);        mLocationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);        if (ContextCompat.checkSelfPermission(this,                Manifest.permission.ACCESS_FINE_LOCATION)                == PackageManager.PERMISSION_GRANTED) {            LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient, mLocationRequest, this);        }    }    @Override    public void onConnectionFailed(@NonNull ConnectionResult connectionResult) {    }    @Override    public void onConnectionSuspended(int i) {    }    @Override    public void onLocationChanged(Location location) {        mLastLocation = location;        if (location.getAccuracy() < 100.0 && location.getSpeed() < 6.95) {            //Place current location marker            LatLng latLng = new LatLng(location.getLatitude(), location.getLongitude());            if (mCurrLocationMarker == null) {                drawMarker(latLng);            } else {                updateMarker(latLng);            }            if (line != null) {                double tolerance = 50;                boolean isLocationOnPath = PolyUtil.isLocationOnEdge(latLng, line.getPoints(), true, tolerance);                if (!isLocationOnPath) {                    //Toast.makeText(getApplicationContext(), "updating Route", Toast.LENGTH_SHORT).show();                    String url = getDirectionsUrl(fromPosition, latLng, toPosition);                    DownloadTask downloadTask = new DownloadTask();                    downloadTask.execute(url);                }            }        }    }    Polyline line;    private void updateMarker(LatLng position) {        //mCurrLocationMarker.setPosition(position);        Location currLoc = new Location("curr");        currLoc.setLatitude(position.latitude);        currLoc.setLongitude(position.longitude);        if (prevLat == 0.0 && prevLng == 0.0) {            prevLat = position.latitude;            prevLng = position.longitude;        }        Location prevLoc = new Location("prev");        prevLoc.setLatitude(prevLat);        prevLoc.setLongitude(prevLng);        animateMarker(prevLoc, currLoc, mCurrLocationMarker);        prevLat = position.latitude;        prevLng = position.longitude;    }    double prevLat = 0.0, prevLng = 0.0;    private void drawMarker(LatLng position) {        int resource;        if (driverCategory.equals("4"))            resource = R.drawable.motor_bike_nav;        else if (driverCategory.equals("1"))            resource = R.drawable.taxi_nav;        else if (driverCategory.equals("3"))            resource = R.drawable.premium_nav;        else if (driverCategory.equals("2"))            resource = R.drawable.economy_nav;        else            resource = R.drawable.taxi_nav;        MarkerOptions markerOptions = new MarkerOptions().position(position)                .icon(BitmapDescriptorFactory.fromResource(resource))                .anchor(0.5f, 0.5f).flat(true);        mCurrLocationMarker = googleMap.addMarker(markerOptions);        //CameraUpdate cameraUpdate = CameraUpdateFactory.newLatLngZoom(position, 12);        //googleMap.animateCamera(cameraUpdate);    }    public void animateMarker(final Location prevLoc, final Location currLoc, final Marker marker) {        if (marker != null && currLoc != null) {            final LatLng endPosition = new LatLng(currLoc.getLatitude(), currLoc.getLongitude());            final LatLngInterpolator latLngInterpolator = new LatLngInterpolator.LinearFixed();            ValueAnimator valueAnimator = new ValueAnimator();            //final LatLng startPosition = marker.getPosition();            final LatLng startPosition = new LatLng(prevLoc.getLatitude(), prevLoc.getLongitude());            valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {                @Override                public void onAnimationUpdate(ValueAnimator animation) {                    try {                        float v = animation.getAnimatedFraction();                        LatLng newPosition = latLngInterpolator.interpolate(v, startPosition, endPosition);                        marker.setPosition(newPosition);                        marker.setFlat(true);                        float bearing = (float) bearingBetweenLocations(                                new LatLng(prevLoc.getLatitude(), prevLoc.getLongitude())                                , new LatLng(currLoc.getLatitude(), currLoc.getLongitude()));                        rotateMarker(marker, bearing);                    } catch (Exception ex) {                        // I don't care atm..                        ex.printStackTrace();                    }                }            });            valueAnimator.setFloatValues(0, 1);            valueAnimator.setDuration(300);            valueAnimator.start();        }    }    boolean isMarkerRotating = false;    private double bearingBetweenLocations(LatLng latLng1, LatLng latLng2) {        double PI = 3.14159;        double lat1 = latLng1.latitude * PI / 180;        double long1 = latLng1.longitude * PI / 180;        double lat2 = latLng2.latitude * PI / 180;        double long2 = latLng2.longitude * PI / 180;        double dLon = (long2 - long1);        double y = Math.sin(dLon) * Math.cos(lat2);        double x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1)                * Math.cos(lat2) * Math.cos(dLon);        double brng = Math.atan2(y, x);        brng = Math.toDegrees(brng);        brng = (brng + 360) % 360;        return brng;    }    private void rotateMarker(final Marker marker, final float toRotation) {        if (!isMarkerRotating) {            final Handler handler = new Handler();            final long start = SystemClock.uptimeMillis();            final float startRotation = marker.getRotation();            final long duration = 2000;            final Interpolator interpolator = new LinearInterpolator();            handler.post(new Runnable() {                @Override                public void run() {                    isMarkerRotating = true;                    long elapsed = SystemClock.uptimeMillis() - start;                    float t = interpolator.getInterpolation((float) elapsed / duration);                    float rot = t * toRotation + (1 - t) * startRotation;                    float bearing = -rot > 180 ? rot / 2 : rot;                    marker.setRotation(bearing);                    if (t < 1.0) {                        // Post again 16ms later.                        handler.postDelayed(this, 16);                    } else {                        isMarkerRotating = false;                    }                }            });        }    }}